import * as tslib_1 from "tslib";
import { Component, Input, Output, EventEmitter, HostListener, ViewEncapsulation } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
import { defaultDateRangePickerOptions } from '../../constants';
import * as momentNs from 'moment';
const moment = momentNs;
let instanceCount = 0;
let DateRangePickerComponent = class DateRangePickerComponent {
    constructor() {
        this.options = defaultDateRangePickerOptions;
        this.controlName = 'dateRange';
        this.instanceId = null;
        this.fromDate = null;
        this.toDate = null;
        this.rangeSelected = new EventEmitter();
        this.range = '';
        this.showCalendars = false;
        if (!this.instanceId) {
            // assign auto-id
            this.instanceId = `dateRangePicker-${instanceCount++}`;
        }
    }
    get enableApplyButton() {
        return !this.options.autoApply && !this.options.singleCalendar && this.fromDate !== null && this.toDate !== null;
    }
    handleClick(event) {
        const target = event.target;
        // close the DatePicker if clicking outside is not allowed
        if (!this.options.clickOutsideAllowed) {
            const containerElementClassRoot = 'dateRangePicker';
            const targetPathClassNames = event['path'].map(obj => obj.className) || [''];
            const targetExistsInPath = targetPathClassNames.some(className => {
                if (typeof className === 'string') {
                    return className && className.includes(containerElementClassRoot);
                }
                return false;
            });
            if (!targetExistsInPath) {
                this.toggleCalendarVisibility(false);
            }
        }
        // Close the DatePicker if the target input was clicked
        if (target.id === this.instanceId) {
            this.toggleCalendarVisibility(!this.showCalendars);
        }
    }
    ngOnInit() {
        // ensure dates in options are valid
        this.validateOptionDates();
        // ensure input dates are within the min/max dates in options
        this.validateInputDates();
        if (this.options.preDefinedRanges && this.options.preDefinedRanges.length > 0) {
            this.defaultRanges = this.validateAndAssignPredefinedRanges(this.options.preDefinedRanges);
        }
        // assign values not present in options with default values
        const optionsKeys = Object.keys(this.options);
        const defaultValuesKeys = Object.keys(defaultDateRangePickerOptions);
        defaultValuesKeys.forEach((key) => {
            if (!optionsKeys.includes(key)) {
                this.options[key] = defaultDateRangePickerOptions[key];
            }
        });
        // update calendar grid
        this.updateCalendar();
        // create parent form group if it doesn't exist
        if (!this.parentFormGroup) {
            this.parentFormGroup = new FormGroup({});
        }
        // add form control to parent form group
        const value = this.formatRangeAsString();
        const control = new FormControl(value, this.options.validators);
        if (this.options.disabled) {
            control.disable();
        }
        this.parentFormGroup.addControl(this.controlName, control);
        // set value of control
        this.setRange();
    }
    validateInputDates() {
        if (this.fromDate && this.options.minDate && this.fromDate.isBefore(this.options.minDate, 'date')) {
            throw new RangeError('@Input fromDate is before the specified minDate in options');
        }
        if (this.toDate && this.options.maxDate && this.toDate.isAfter(this.options.maxDate, 'date')) {
            throw new RangeError('@Input toDate is after the specified maxDate in options');
        }
    }
    validateOptionDates() {
        // validate maxDate isn't before minDate or vice versa
        if (this.options) {
            if (this.options.minDate && this.options.maxDate) {
                if (this.options.minDate.isAfter(this.options.maxDate, 'date')) {
                    throw new RangeError('minDate specified in options is after the maxDate');
                }
                else if (this.options.maxDate.isBefore(this.options.minDate, 'date')) {
                    throw new RangeError('maxDate specified in options is before the minDate');
                }
            }
        }
    }
    // assists CSS to fix small positioning bug with From:/To: date text
    checkChrome() {
        return window['chrome'] ? 'is-chrome' : '';
    }
    toggleCalendarVisibility(value) {
        this.showCalendars = value !== null ? value : !this.showCalendars;
    }
    setFromToMonthYear(fromDate, toDate) {
        const tempFromDate = fromDate || this.fromDate || this.options.startingFromDate || moment();
        const tempToDate = toDate || this.toDate || this.options.startingToDate || moment();
        this.fromMonth = tempFromDate.get('month');
        this.fromYear = tempFromDate.get('year');
        this.toMonth = tempToDate.get('month');
        this.toYear = tempToDate.get('year');
    }
    updateCalendar() {
        // get month and year to show calendar
        this.setFromToMonthYear();
        this.setRange();
    }
    // update from/to based on selection
    dateChanged(changedData) {
        const value = changedData.day;
        const isLeft = changedData.isLeft;
        if (isLeft) {
            this.fromDate = value;
            if (this.fromDate.isAfter(this.toDate, 'date')) {
                this.toDate = this.fromDate.clone();
            }
        }
        else {
            this.toDate = value;
            if (this.toDate.isBefore(this.fromDate, 'date')) {
                this.fromDate = this.toDate.clone();
            }
        }
        this.setFromToMonthYear(this.fromDate, this.toDate);
        if (this.isAutoApply() && (this.options.singleCalendar || !isLeft) && this.fromDate) {
            this.toggleCalendarVisibility(false);
            this.setRange();
            this.emitRangeSelected();
        }
    }
    emitRangeSelected(data) {
        if (!data) {
            data = this.options.singleCalendar ? { start: this.fromDate } : { start: this.fromDate, end: this.toDate };
        }
        this.rangeSelected.emit(data);
    }
    getMoment(value) {
        return moment(value, this.options.format);
    }
    formatRangeAsString() {
        let range = '';
        if (this.options.singleCalendar && this.fromDate) {
            range = this.fromDate.format(this.options.format);
        }
        else if (!this.options.singleCalendar && this.fromDate && this.toDate) {
            range = `${this.fromDate.format(this.options.format)} - ${this.toDate.format(this.options.format)}`;
        }
        return range;
    }
    setRange() {
        this.range = this.formatRangeAsString();
        if (this.parentFormGroup) {
            const control = this.parentFormGroup.get(this.controlName);
            if (control) {
                control.setValue(this.range);
                control.updateValueAndValidity();
            }
        }
    }
    setDateFromInput(event, isLeft = false) {
        const target = event.target;
        try {
            if (target.value) {
                const day = this.getMoment(target.value);
                if (!day.isBefore(this.options.minDate) && !day.isAfter(this.options.maxDate)) {
                    if (isLeft && !this.fromDate) {
                        this.fromDate = day;
                    }
                    if (!isLeft && !this.toDate) {
                        this.toDate = day;
                    }
                    this.dateChanged({
                        day,
                        isLeft,
                    });
                    this.setFromToMonthYear(this.fromDate, this.toDate);
                }
                else {
                    // assume nothing - reset values
                    this.fromDate = null;
                    this.toDate = null;
                    target.value = '';
                    target.focus();
                }
            }
            this.emitRangeSelected();
        }
        catch (e) {
            console.error(e);
        }
    }
    monthChanged(data) {
        let temp;
        if (data.isLeft) {
            temp = moment([this.fromYear, this.fromMonth]).add(data.value, 'months');
            this.fromMonth = temp.get('month');
            this.fromYear = temp.get('year');
        }
        else {
            temp = moment([this.toYear, this.toMonth]).add(data.value, 'months');
            this.toMonth = temp.get('month');
            this.toYear = temp.get('year');
        }
    }
    yearChanged(data) {
        let temp;
        if (data.isLeft) {
            temp = moment([this.fromYear, this.fromMonth]).add(data.value, 'year');
            this.fromMonth = temp.get('month');
            this.fromYear = temp.get('year');
        }
        else {
            temp = moment([this.toYear, this.toMonth]).add(data.value, 'year');
            this.toMonth = temp.get('month');
            this.toYear = temp.get('year');
        }
    }
    close(event) {
        this.toggleCalendarVisibility(false);
        event.stopPropagation();
    }
    reset(event) {
        this.fromDate = null;
        this.toDate = null;
        this.setRange();
        event.stopPropagation();
    }
    apply(event) {
        this.toggleCalendarVisibility(false);
        this.setRange();
        this.emitRangeSelected();
        event.stopPropagation();
    }
    applyPredefinedRange(event, definedDateRange) {
        // adjust to/from month/year so calendar months and years match range
        this.setFromToMonthYear(definedDateRange.value.start, definedDateRange.value.end);
        this.fromDate = definedDateRange.value.start;
        this.toDate = definedDateRange.value.end;
        if (this.options.autoApply) {
            this.apply(event);
        }
    }
    validateAndAssignPredefinedRanges(ranges) {
        return ranges.filter(range => {
            if (range.value.start.isAfter(range.value.end, 'date')) {
                throw new RangeError(`Pre-defined range "${range.name}" start date cannot be after the end date for the range.`);
            }
            if (this.options.minDate && range.value.start.isBefore(this.options.minDate)) {
                throw new RangeError(`Pre-defined range "${range.name}" start date is before the specified minDate in your options.`);
            }
            if (this.options.maxDate && range.value.end.isAfter(this.options.maxDate)) {
                throw new RangeError(`Pre-defined range "${range.name}" end date is after the specified maxDate in your options.`);
            }
            // add range to ranges
            return true;
        });
    }
    isAutoApply() {
        if (this.options.singleCalendar) {
            return true;
        }
        else {
            return this.options.autoApply;
        }
    }
};
tslib_1.__decorate([
    Input()
], DateRangePickerComponent.prototype, "options", void 0);
tslib_1.__decorate([
    Input()
], DateRangePickerComponent.prototype, "controlName", void 0);
tslib_1.__decorate([
    Input()
], DateRangePickerComponent.prototype, "instanceId", void 0);
tslib_1.__decorate([
    Input()
], DateRangePickerComponent.prototype, "parentFormGroup", void 0);
tslib_1.__decorate([
    Input()
], DateRangePickerComponent.prototype, "fromDate", void 0);
tslib_1.__decorate([
    Input()
], DateRangePickerComponent.prototype, "toDate", void 0);
tslib_1.__decorate([
    Output()
], DateRangePickerComponent.prototype, "rangeSelected", void 0);
tslib_1.__decorate([
    HostListener('document:click', ['$event'])
], DateRangePickerComponent.prototype, "handleClick", null);
DateRangePickerComponent = tslib_1.__decorate([
    Component({
        encapsulation: ViewEncapsulation.None,
        selector: 'date-range-picker',
        template: "<div class=\"dateRangePicker-wrapper\" *ngIf=\"parentFormGroup\">\n  <div #content>\n    <ng-content></ng-content>\n  </div>\n  <div class=\"form-group\" [formGroup]=\"parentFormGroup\">\n    <ng-container *ngIf=\"content.childNodes.length === 0\">\n      <label [attr.for]=\"instanceId\">{{ options.labelText }}</label>\n      <input [attr.id]=\"instanceId\" class=\"form-control\" type=\"text\" [formControlName]=\"controlName\">\n    </ng-container>\n\n    <div [ngClass]=\"{'dateRangePicker': true, 'invisible': !showCalendars, 'dateRangePicker-single': options.singleCalendar, 'is-chrome': checkChrome(), 'open-left': options.position === 'left', 'open-right': options.position === 'right' }\">\n      <div class=\"container-fluid\">\n        <div class=\"row\">\n          <div class=\"col\">\n\n            <div class=\"row form-inputs mb-0\" *ngIf=\"!options.singleCalendar\">\n\n              <div class=\"col\">\n                <div class=\"\" *ngIf=\"options.icons !== 'default'\">\n                  <div [ngClass]=\"{ 'd-flex align-items-center input-with-icon': true, 'material': options.icons === 'material'}\">\n                    <i *ngIf=\"options.icons === 'material'\" class=\"material-icons\">event</i>\n                    <i *ngIf=\"options.icons === 'font-awesome'\" class=\"far fa-calendar-alt\"></i>\n                    <span *ngIf=\"fromDate\">From:&nbsp;</span>\n                    <input class=\"form-control\" [ngModel]=\"fromDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event, true)\" type=\"text\" name=\"daterangepicker_start\" [ngModelOptions]=\"{ standalone: true }\" placeholder=\"Select From Date\" />\n                  </div>\n                </div>\n\n                <input *ngIf=\"options.icons === 'default'\" class=\"form-control\" [ngModel]=\"fromDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event, true)\" type=\"text\" name=\"daterangepicker_start\" [ngModelOptions]=\"{standalone: true}\" placeholder=\"Select From Date\" />\n              </div>\n\n              <div class=\"col\">\n                <div class=\"\" *ngIf=\"options.icons !== 'default'\">\n                    <div [ngClass]=\"{ 'd-flex align-items-center input-with-icon': true, 'material': options.icons === 'material'}\">\n                      <i *ngIf=\"options.icons === 'material'\" class=\"material-icons\">event</i>\n                      <i *ngIf=\"options.icons === 'font-awesome'\" class=\"far fa-calendar-alt\"></i>\n                      <span *ngIf=\"toDate\">To:&nbsp;</span>\n                      <input class=\"form-control\" [ngModel]=\"toDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event)\" type=\"text\" name=\"daterangepicker_end\" [ngModelOptions]=\"{ standalone: true }\" placeholder=\"Select To Date\" />\n                    </div>\n                  </div>\n\n                <input *ngIf=\"options.icons === 'default'\" class=\"form-control\" [ngModel]=\"toDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event)\" name=\"daterangepicker_end\" [ngModelOptions]=\"{standalone: true}\" />\n              </div>\n\n            </div>\n\n            <div class=\"row row-calendars\">\n              <div class=\"col\">\n                <calendar [ngClass]=\"{ 'calendar': true, 'calendar-single': options.singleCalendar }\" [isLeft]=\"true\" [month]=\"fromMonth\" [year]=\"fromYear\" (monthChanged)=monthChanged($event)\n                  (yearChanged)=\"yearChanged($event)\" (dateChanged)=\"dateChanged($event)\" [format]=\"options.format\" [selectedFromDate]=\"fromDate\"\n                  [selectedToDate]=\"toDate\" [minDate]=\"options.minDate\" [maxDate]=\"options.maxDate\" [singleCalendar]=\"options.singleCalendar\" [icons]=\"options.icons\"></calendar>\n              </div>\n\n              <div class=\"col\" *ngIf=\"!options.singleCalendar\">\n                <calendar class=\"calendar\" [month]=\"toMonth\" [year]=\"toYear\" [format]=\"options.format\" (dateChanged)=\"dateChanged($event)\" (monthChanged)=\"monthChanged($event)\" (yearChanged)=yearChanged($event) [selectedFromDate]=\"fromDate\" [selectedToDate]=\"toDate\" [minDate]=\"options.minDate\" [maxDate]=\"options.maxDate\" [icons]=\"options.icons\"></calendar>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"row text-center my-3\" *ngIf=\"!options.singleCalendar\">\n          <div class=\"col\">\n            <div class=\"row mb-2\" *ngIf=\"options.preDefinedRanges && options.preDefinedRanges.length > 0\">\n              <div class=\"col\">\n                <button type=\"button\" *ngFor=\"let range of options.preDefinedRanges\" class=\"btn btn-link\" (click)=\"applyPredefinedRange($event, range)\">{{ range.name }}</button>\n              </div>\n            </div>\n            <button type=\"button\" class=\"btn btn-outline-secondary btn-sm\" (click)=\"close($event)\">Close</button>\n            <button type=\"button\" class=\"btn btn-outline-secondary btn-sm ml-3\" (click)=\"reset($event)\" *ngIf=\"this.range\">Reset</button>\n            <button type=\"button\" class=\"btn btn-primary btn-sm ml-3\" [disabled]=\"!enableApplyButton\" (click)=\"apply($event)\" *ngIf=\"!isAutoApply()\">Apply</button>\n          </div>\n        </div>\n\n      </div>\n    </div>\n\n  </div>\n</div>\n",
        styles: [".dateRangePicker-wrapper{position:relative;border:none}.dateRangePicker-wrapper .dateRangePicker{background:#fff;border-radius:9px;box-shadow:0 0 10px 0 rgba(129,139,144,.5);font-family:Roboto,Helvetica,Arial,sans-serif;overflow:visible;position:absolute;top:88px;z-index:3000}.dateRangePicker-wrapper .dateRangePicker.dateRangePicker-single{min-width:300px}@media screen and (min-width:576px){.dateRangePicker-wrapper .dateRangePicker{min-width:600px}}.dateRangePicker-wrapper .dateRangePicker::after,.dateRangePicker-wrapper .dateRangePicker::before{content:\"\";height:0;width:0;border-bottom:10px solid #6e777c;border-left:10px solid transparent;border-right:10px solid transparent;position:absolute;top:-10px}.dateRangePicker-wrapper .dateRangePicker.open-left{left:0}.dateRangePicker-wrapper .dateRangePicker.open-left::before{left:10px}.dateRangePicker-wrapper .dateRangePicker.open-left::after{display:none}.dateRangePicker-wrapper .dateRangePicker.open-right{right:0}.dateRangePicker-wrapper .dateRangePicker.open-right::before{display:none}.dateRangePicker-wrapper .dateRangePicker.open-right::after{right:10px}.dateRangePicker-wrapper .dateRangePicker.is-chrome .form-inputs .input-with-icon span{position:relative;top:1px}.dateRangePicker-wrapper .dateRangePicker .btn,.dateRangePicker-wrapper .dateRangePicker .btn.btn-link{min-width:auto;width:auto}.dateRangePicker-wrapper .dateRangePicker .form-inputs{background-color:#6e777c;border-top-left-radius:8px;border-top-right-radius:8px;color:#fff;font-size:16px}.dateRangePicker-wrapper .dateRangePicker .form-inputs>.col{padding:.5rem 15px;min-width:270px}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon{display:flex;align-content:flex-start;align-items:center!important}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon i{color:#fff;margin-right:.5rem}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon i.material-icons{top:0}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon span{line-height:1}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control{background:0 0;border:0;color:#fff;display:inline-block;padding:0;width:150px}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::-webkit-input-placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::-moz-placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::-ms-input-placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs>div:nth-child(2),.dateRangePicker-wrapper .dateRangePicker .row-calendars>div:nth-child(2){border-left:2px solid #c6d1d6}.dateRangePicker-wrapper i.material-icons{position:relative;top:2px}"]
    })
], DateRangePickerComponent);
export { DateRangePickerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWRhdGVyYW5nZS8iLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvZGF0ZXBpY2tlci9kYXRlLXJhbmdlLXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFVLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hILE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEQsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHaEUsT0FBTyxLQUFLLFFBQVEsTUFBTSxRQUFRLENBQUM7QUFBQyxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFFNUQsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0FBVXRCLElBQWEsd0JBQXdCLEdBQXJDLE1BQWEsd0JBQXdCO0lBOERuQztRQTNEQSxZQUFPLEdBQTRCLDZCQUE2QixDQUFDO1FBR2pFLGdCQUFXLEdBQVcsV0FBVyxDQUFDO1FBR2xDLGVBQVUsR0FBVyxJQUFJLENBQUM7UUFNMUIsYUFBUSxHQUFvQixJQUFJLENBQUM7UUFHakMsV0FBTSxHQUFvQixJQUFJLENBQUM7UUFHL0Isa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO1FBTy9DLFVBQUssR0FBRyxFQUFFLENBQUM7UUFDWCxrQkFBYSxHQUFHLEtBQUssQ0FBQztRQWtDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDcEIsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyxVQUFVLEdBQUcsbUJBQW9CLGFBQWEsRUFBRyxFQUFFLENBQUM7U0FDMUQ7SUFDSCxDQUFDO0lBcENELElBQUksaUJBQWlCO1FBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FB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LE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDekUsTUFBTSxJQUFJLFVBQVUsQ0FBQyxzQkFBdUIsS0FBSyxDQUFDLElBQUssNERBQTRELENBQUMsQ0FBQzthQUN0SDtZQUVELHNCQUFzQjtZQUN0QixPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFO1lBQy9CLE9BQU8sSUFBSSxDQUFDO1NBQ2I7YUFDSTtZQUNILE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7U0FDL0I7SUFDSCxDQUFDO0NBQ0YsQ0FBQTtBQXBXQztJQURDLEtBQUssRUFBRTt5REFDeUQ7QUFHakU7SUFEQyxLQUFLLEVBQUU7NkRBQzBCO0FBR2xDO0lBREMsS0FBSyxFQUFFOzREQUNrQjtBQUcxQjtJQURDLEtBQUssRUFBRTtpRUFDbUI7QUFHM0I7SUFEQyxLQUFLLEVBQUU7MERBQ3lCO0FBR2pDO0lBREMsS0FBSyxFQUFFO3dEQUN1QjtBQUcvQjtJQURDLE1BQU0sRUFBRTsrREFDc0M7QUFlL0M7SUFEQyxZQUFZLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzsyREF5QjFDO0FBNURVLHdCQUF3QjtJQVJwQyxTQUFTLENBQUM7UUFDVCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtRQUNyQyxRQUFRLEVBQUUsbUJBQW1CO1FBSTdCLG13S0FBaUQ7O0tBQ2xELENBQUM7R0FDVyx3QkFBd0IsQ0F1V3BDO1NBdldZLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIE9uSW5pdCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCwgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IGRlZmF1bHREYXRlUmFuZ2VQaWNrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IElEYXRlUmFuZ2UsIElEYXRlUmFuZ2VQaWNrZXJPcHRpb25zLCBJRGVmaW5lZERhdGVSYW5nZSwgSUNoYW5nZWREYXRhIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcyc7XG5cbmltcG9ydCAqIGFzIG1vbWVudE5zIGZyb20gJ21vbWVudCc7IGNvbnN0IG1vbWVudCA9IG1vbWVudE5zO1xuXG5sZXQgaW5zdGFuY2VDb3VudCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBzZWxlY3RvcjogJ2RhdGUtcmFuZ2UtcGlja2VyJyxcbiAgc3R5bGVVcmxzOiBbXG4gICAgJy4vZGF0ZS1yYW5nZS1waWNrZXIuY29tcG9uZW50LnNjc3MnLFxuICBdLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS1yYW5nZS1waWNrZXIuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBEYXRlUmFuZ2VQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBJbnB1dCgpXG4gIG9wdGlvbnM6IElEYXRlUmFuZ2VQaWNrZXJPcHRpb25zID0gZGVmYXVsdERhdGVSYW5nZVBpY2tlck9wdGlvbnM7XG5cbiAgQElucHV0KClcbiAgY29udHJvbE5hbWU6IHN0cmluZyA9ICdkYXRlUmFuZ2UnO1xuXG4gIEBJbnB1dCgpXG4gIGluc3RhbmNlSWQ6IHN0cmluZyA9IG51bGw7XG5cbiAgQElucHV0KClcbiAgcGFyZW50Rm9ybUdyb3VwOiBGb3JtR3JvdXA7XG5cbiAgQElucHV0KClcbiAgZnJvbURhdGU6IG1vbWVudE5zLk1vbWVudCA9IG51bGw7XG5cbiAgQElucHV0KClcbiAgdG9EYXRlOiBtb21lbnROcy5Nb21lbnQgPSBudWxsO1xuXG4gIEBPdXRwdXQoKVxuICByYW5nZVNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcjxJRGF0ZVJhbmdlPigpO1xuXG4gIGRlZmF1bHRSYW5nZXM6IElEZWZpbmVkRGF0ZVJhbmdlW107XG4gIGZyb21Nb250aDogbnVtYmVyO1xuICBmcm9tWWVhcjogbnVtYmVyO1xuICB0b01vbnRoOiBudW1iZXI7XG4gIHRvWWVhcjogbnVtYmVyO1xuICByYW5nZSA9ICcnO1xuICBzaG93Q2FsZW5kYXJzID0gZmFsc2U7XG5cbiAgZ2V0IGVuYWJsZUFwcGx5QnV0dG9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5vcHRpb25zLmF1dG9BcHBseSAmJiAhdGhpcy5vcHRpb25zLnNpbmdsZUNhbGVuZGFyICYmIHRoaXMuZnJvbURhdGUgIT09IG51bGwgJiYgdGhpcy50b0RhdGUgIT09IG51bGw7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gIGhhbmRsZUNsaWNrKGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gICAgLy8gY2xvc2UgdGhlIERhdGVQaWNrZXIgaWYgY2xpY2tpbmcgb3V0c2lkZSBpcyBub3QgYWxsb3dlZFxuICAgIGlmICghdGhpcy5vcHRpb25zLmNsaWNrT3V0c2lkZUFsbG93ZWQpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckVsZW1lbnRDbGFzc1Jvb3QgPSAnZGF0ZVJhbmdlUGlja2VyJztcbiAgICAgIGNvbnN0IHRhcmdldFBhdGhDbGFzc05hbWVzOiBzdHJpbmdbXSA9IGV2ZW50WydwYXRoJ10ubWFwKG9iaiA9PiBvYmouY2xhc3NOYW1lKSB8fCBbJyddO1xuICAgICAgY29uc3QgdGFyZ2V0RXhpc3RzSW5QYXRoID0gdGFyZ2V0UGF0aENsYXNzTmFtZXMuc29tZShjbGFzc05hbWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmNsdWRlcyhjb250YWluZXJFbGVtZW50Q2xhc3NSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRhcmdldEV4aXN0c0luUGF0aCkge1xuICAgICAgICB0aGlzLnRvZ2dsZUNhbGVuZGFyVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xvc2UgdGhlIERhdGVQaWNrZXIgaWYgdGhlIHRhcmdldCBpbnB1dCB3YXMgY2xpY2tlZFxuICAgIGlmICh0YXJnZXQuaWQgPT09IHRoaXMuaW5zdGFuY2VJZCkge1xuICAgICAgdGhpcy50b2dnbGVDYWxlbmRhclZpc2liaWxpdHkoIXRoaXMuc2hvd0NhbGVuZGFycyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlSWQpIHtcbiAgICAgIC8vIGFzc2lnbiBhdXRvLWlkXG4gICAgICB0aGlzLmluc3RhbmNlSWQgPSBgZGF0ZVJhbmdlUGlja2VyLSR7IGluc3RhbmNlQ291bnQrKyB9YDtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAvLyBlbnN1cmUgZGF0ZXMgaW4gb3B0aW9ucyBhcmUgdmFsaWRcbiAgICB0aGlzLnZhbGlkYXRlT3B0aW9uRGF0ZXMoKTtcblxuICAgIC8vIGVuc3VyZSBpbnB1dCBkYXRlcyBhcmUgd2l0aGluIHRoZSBtaW4vbWF4IGRhdGVzIGluIG9wdGlvbnNcbiAgICB0aGlzLnZhbGlkYXRlSW5wdXREYXRlcygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVEZWZpbmVkUmFuZ2VzICYmIHRoaXMub3B0aW9ucy5wcmVEZWZpbmVkUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZGVmYXVsdFJhbmdlcyA9IHRoaXMudmFsaWRhdGVBbmRBc3NpZ25QcmVkZWZpbmVkUmFuZ2VzKHRoaXMub3B0aW9ucy5wcmVEZWZpbmVkUmFuZ2VzKTtcbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gdmFsdWVzIG5vdCBwcmVzZW50IGluIG9wdGlvbnMgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVzS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHREYXRlUmFuZ2VQaWNrZXJPcHRpb25zKTtcblxuICAgIGRlZmF1bHRWYWx1ZXNLZXlzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbnNLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBkZWZhdWx0RGF0ZVJhbmdlUGlja2VyT3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIGNhbGVuZGFyIGdyaWRcbiAgICB0aGlzLnVwZGF0ZUNhbGVuZGFyKCk7XG5cbiAgICAvLyBjcmVhdGUgcGFyZW50IGZvcm0gZ3JvdXAgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghdGhpcy5wYXJlbnRGb3JtR3JvdXApIHtcbiAgICAgIHRoaXMucGFyZW50Rm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGZvcm0gY29udHJvbCB0byBwYXJlbnQgZm9ybSBncm91cFxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtYXRSYW5nZUFzU3RyaW5nKCk7XG4gICAgY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCh2YWx1ZSwgdGhpcy5vcHRpb25zLnZhbGlkYXRvcnMpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgY29udHJvbC5kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJlbnRGb3JtR3JvdXAuYWRkQ29udHJvbCh0aGlzLmNvbnRyb2xOYW1lLCBjb250cm9sKTtcblxuICAgIC8vIHNldCB2YWx1ZSBvZiBjb250cm9sXG4gICAgdGhpcy5zZXRSYW5nZSgpO1xuICB9XG5cbiAgdmFsaWRhdGVJbnB1dERhdGVzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmZyb21EYXRlICYmIHRoaXMub3B0aW9ucy5taW5EYXRlICYmIHRoaXMuZnJvbURhdGUuaXNCZWZvcmUodGhpcy5vcHRpb25zLm1pbkRhdGUsICdkYXRlJykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdASW5wdXQgZnJvbURhdGUgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgbWluRGF0ZSBpbiBvcHRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9EYXRlICYmIHRoaXMub3B0aW9ucy5tYXhEYXRlICYmIHRoaXMudG9EYXRlLmlzQWZ0ZXIodGhpcy5vcHRpb25zLm1heERhdGUsICdkYXRlJykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdASW5wdXQgdG9EYXRlIGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgbWF4RGF0ZSBpbiBvcHRpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVPcHRpb25EYXRlcygpOiB2b2lkIHtcbiAgICAvLyB2YWxpZGF0ZSBtYXhEYXRlIGlzbid0IGJlZm9yZSBtaW5EYXRlIG9yIHZpY2UgdmVyc2FcbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1pbkRhdGUgJiYgdGhpcy5vcHRpb25zLm1heERhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5EYXRlLmlzQWZ0ZXIodGhpcy5vcHRpb25zLm1heERhdGUsICdkYXRlJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWluRGF0ZSBzcGVjaWZpZWQgaW4gb3B0aW9ucyBpcyBhZnRlciB0aGUgbWF4RGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhEYXRlLmlzQmVmb3JlKHRoaXMub3B0aW9ucy5taW5EYXRlLCAnZGF0ZScpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21heERhdGUgc3BlY2lmaWVkIGluIG9wdGlvbnMgaXMgYmVmb3JlIHRoZSBtaW5EYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhc3Npc3RzIENTUyB0byBmaXggc21hbGwgcG9zaXRpb25pbmcgYnVnIHdpdGggRnJvbTovVG86IGRhdGUgdGV4dFxuICBjaGVja0Nocm9tZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB3aW5kb3dbJ2Nocm9tZSddID8gJ2lzLWNocm9tZScgOiAnJztcbiAgfVxuXG4gIHRvZ2dsZUNhbGVuZGFyVmlzaWJpbGl0eSh2YWx1ZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLnNob3dDYWxlbmRhcnMgPSB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlIDogIXRoaXMuc2hvd0NhbGVuZGFycztcbiAgfVxuXG4gIHNldEZyb21Ub01vbnRoWWVhcihmcm9tRGF0ZT86IG1vbWVudE5zLk1vbWVudCwgdG9EYXRlPzogbW9tZW50TnMuTW9tZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGVtcEZyb21EYXRlID0gZnJvbURhdGUgfHwgdGhpcy5mcm9tRGF0ZSB8fCB0aGlzLm9wdGlvbnMuc3RhcnRpbmdGcm9tRGF0ZSB8fCBtb21lbnQoKTtcbiAgICBjb25zdCB0ZW1wVG9EYXRlID0gdG9EYXRlIHx8IHRoaXMudG9EYXRlIHx8IHRoaXMub3B0aW9ucy5zdGFydGluZ1RvRGF0ZSB8fCBtb21lbnQoKTtcblxuICAgIHRoaXMuZnJvbU1vbnRoID0gdGVtcEZyb21EYXRlLmdldCgnbW9udGgnKTtcbiAgICB0aGlzLmZyb21ZZWFyID0gdGVtcEZyb21EYXRlLmdldCgneWVhcicpO1xuXG4gICAgdGhpcy50b01vbnRoID0gdGVtcFRvRGF0ZS5nZXQoJ21vbnRoJyk7XG4gICAgdGhpcy50b1llYXIgPSB0ZW1wVG9EYXRlLmdldCgneWVhcicpO1xuICB9XG5cbiAgdXBkYXRlQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgLy8gZ2V0IG1vbnRoIGFuZCB5ZWFyIHRvIHNob3cgY2FsZW5kYXJcbiAgICB0aGlzLnNldEZyb21Ub01vbnRoWWVhcigpO1xuICAgIHRoaXMuc2V0UmFuZ2UoKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBmcm9tL3RvIGJhc2VkIG9uIHNlbGVjdGlvblxuICBkYXRlQ2hhbmdlZChjaGFuZ2VkRGF0YTogSUNoYW5nZWREYXRhKTogdm9pZCB7XG4gICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VkRGF0YS5kYXk7XG4gICAgY29uc3QgaXNMZWZ0ID0gY2hhbmdlZERhdGEuaXNMZWZ0O1xuXG4gICAgaWYgKGlzTGVmdCkge1xuICAgICAgdGhpcy5mcm9tRGF0ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5mcm9tRGF0ZS5pc0FmdGVyKHRoaXMudG9EYXRlLCAnZGF0ZScpKSB7XG4gICAgICAgIHRoaXMudG9EYXRlID0gdGhpcy5mcm9tRGF0ZS5jbG9uZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudG9EYXRlID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnRvRGF0ZS5pc0JlZm9yZSh0aGlzLmZyb21EYXRlLCAnZGF0ZScpKSB7XG4gICAgICAgIHRoaXMuZnJvbURhdGUgPSB0aGlzLnRvRGF0ZS5jbG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0RnJvbVRvTW9udGhZZWFyKHRoaXMuZnJvbURhdGUsIHRoaXMudG9EYXRlKTtcblxuICAgIGlmICh0aGlzLmlzQXV0b0FwcGx5KCkgJiYgKHRoaXMub3B0aW9ucy5zaW5nbGVDYWxlbmRhciB8fCAhaXNMZWZ0KSAmJiB0aGlzLmZyb21EYXRlKSB7XG4gICAgICB0aGlzLnRvZ2dsZUNhbGVuZGFyVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgICB0aGlzLnNldFJhbmdlKCk7XG4gICAgICB0aGlzLmVtaXRSYW5nZVNlbGVjdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgZW1pdFJhbmdlU2VsZWN0ZWQoZGF0YT86IElEYXRlUmFuZ2UpOiB2b2lkIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGRhdGEgPSB0aGlzLm9wdGlvbnMuc2luZ2xlQ2FsZW5kYXIgPyB7IHN0YXJ0OiB0aGlzLmZyb21EYXRlIH0gOiB7IHN0YXJ0OiB0aGlzLmZyb21EYXRlLCBlbmQ6IHRoaXMudG9EYXRlIH07XG4gICAgfVxuXG4gICAgdGhpcy5yYW5nZVNlbGVjdGVkLmVtaXQoZGF0YSk7XG4gIH1cblxuICBnZXRNb21lbnQodmFsdWUpOiBtb21lbnROcy5Nb21lbnQge1xuICAgIHJldHVybiBtb21lbnQodmFsdWUsIHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICB9XG5cbiAgZm9ybWF0UmFuZ2VBc1N0cmluZygpOiBzdHJpbmcge1xuICAgIGxldCByYW5nZSA9ICcnO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaW5nbGVDYWxlbmRhciAmJiB0aGlzLmZyb21EYXRlKSB7XG4gICAgICByYW5nZSA9IHRoaXMuZnJvbURhdGUuZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGhpcy5vcHRpb25zLnNpbmdsZUNhbGVuZGFyICYmIHRoaXMuZnJvbURhdGUgJiYgdGhpcy50b0RhdGUpIHtcbiAgICAgIHJhbmdlID0gYCR7IHRoaXMuZnJvbURhdGUuZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpIH0gLSAkeyB0aGlzLnRvRGF0ZS5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkgfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgc2V0UmFuZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5yYW5nZSA9IHRoaXMuZm9ybWF0UmFuZ2VBc1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucGFyZW50Rm9ybUdyb3VwKSB7XG4gICAgICBjb25zdCBjb250cm9sID0gdGhpcy5wYXJlbnRGb3JtR3JvdXAuZ2V0KHRoaXMuY29udHJvbE5hbWUpO1xuXG4gICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICBjb250cm9sLnNldFZhbHVlKHRoaXMucmFuZ2UpO1xuICAgICAgICBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXREYXRlRnJvbUlucHV0KGV2ZW50OiBFdmVudCwgaXNMZWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRheSA9IHRoaXMuZ2V0TW9tZW50KHRhcmdldC52YWx1ZSk7XG5cbiAgICAgICAgaWYgKCFkYXkuaXNCZWZvcmUodGhpcy5vcHRpb25zLm1pbkRhdGUpICYmICFkYXkuaXNBZnRlcih0aGlzLm9wdGlvbnMubWF4RGF0ZSkpIHtcbiAgICAgICAgICBpZiAoaXNMZWZ0ICYmICF0aGlzLmZyb21EYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21EYXRlID0gZGF5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNMZWZ0ICYmICF0aGlzLnRvRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy50b0RhdGUgPSBkYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kYXRlQ2hhbmdlZCh7XG4gICAgICAgICAgICBkYXksXG4gICAgICAgICAgICBpc0xlZnQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnNldEZyb21Ub01vbnRoWWVhcih0aGlzLmZyb21EYXRlLCB0aGlzLnRvRGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gYXNzdW1lIG5vdGhpbmcgLSByZXNldCB2YWx1ZXNcbiAgICAgICAgICB0aGlzLmZyb21EYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnRvRGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0UmFuZ2VTZWxlY3RlZCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBtb250aENoYW5nZWQoZGF0YTogSUNoYW5nZWREYXRhKTogdm9pZCB7XG4gICAgbGV0IHRlbXA7XG5cbiAgICBpZiAoZGF0YS5pc0xlZnQpIHtcbiAgICAgIHRlbXAgPSBtb21lbnQoW3RoaXMuZnJvbVllYXIsIHRoaXMuZnJvbU1vbnRoXSkuYWRkKGRhdGEudmFsdWUsICdtb250aHMnKTtcbiAgICAgIHRoaXMuZnJvbU1vbnRoID0gdGVtcC5nZXQoJ21vbnRoJyk7XG4gICAgICB0aGlzLmZyb21ZZWFyID0gdGVtcC5nZXQoJ3llYXInKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZW1wID0gbW9tZW50KFt0aGlzLnRvWWVhciwgdGhpcy50b01vbnRoXSkuYWRkKGRhdGEudmFsdWUsICdtb250aHMnKTtcbiAgICAgIHRoaXMudG9Nb250aCA9IHRlbXAuZ2V0KCdtb250aCcpO1xuICAgICAgdGhpcy50b1llYXIgPSB0ZW1wLmdldCgneWVhcicpO1xuICAgIH1cbiAgfVxuXG4gIHllYXJDaGFuZ2VkKGRhdGE6IElDaGFuZ2VkRGF0YSk6IHZvaWQge1xuICAgIGxldCB0ZW1wO1xuXG4gICAgaWYgKGRhdGEuaXNMZWZ0KSB7XG4gICAgICB0ZW1wID0gbW9tZW50KFt0aGlzLmZyb21ZZWFyLCB0aGlzLmZyb21Nb250aF0pLmFkZChkYXRhLnZhbHVlLCAneWVhcicpO1xuICAgICAgdGhpcy5mcm9tTW9udGggPSB0ZW1wLmdldCgnbW9udGgnKTtcbiAgICAgIHRoaXMuZnJvbVllYXIgPSB0ZW1wLmdldCgneWVhcicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRlbXAgPSBtb21lbnQoW3RoaXMudG9ZZWFyLCB0aGlzLnRvTW9udGhdKS5hZGQoZGF0YS52YWx1ZSwgJ3llYXInKTtcbiAgICAgIHRoaXMudG9Nb250aCA9IHRlbXAuZ2V0KCdtb250aCcpO1xuICAgICAgdGhpcy50b1llYXIgPSB0ZW1wLmdldCgneWVhcicpO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIHRoaXMudG9nZ2xlQ2FsZW5kYXJWaXNpYmlsaXR5KGZhbHNlKTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgcmVzZXQoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5mcm9tRGF0ZSA9IG51bGw7XG4gICAgdGhpcy50b0RhdGUgPSBudWxsO1xuICAgIHRoaXMuc2V0UmFuZ2UoKTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgYXBwbHkoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy50b2dnbGVDYWxlbmRhclZpc2liaWxpdHkoZmFsc2UpO1xuICAgIHRoaXMuc2V0UmFuZ2UoKTtcbiAgICB0aGlzLmVtaXRSYW5nZVNlbGVjdGVkKCk7XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGFwcGx5UHJlZGVmaW5lZFJhbmdlKGV2ZW50OiBFdmVudCwgZGVmaW5lZERhdGVSYW5nZTogSURlZmluZWREYXRlUmFuZ2UpOiB2b2lkIHtcbiAgICAvLyBhZGp1c3QgdG8vZnJvbSBtb250aC95ZWFyIHNvIGNhbGVuZGFyIG1vbnRocyBhbmQgeWVhcnMgbWF0Y2ggcmFuZ2VcbiAgICB0aGlzLnNldEZyb21Ub01vbnRoWWVhcihkZWZpbmVkRGF0ZVJhbmdlLnZhbHVlLnN0YXJ0LCBkZWZpbmVkRGF0ZVJhbmdlLnZhbHVlLmVuZCk7XG5cbiAgICB0aGlzLmZyb21EYXRlID0gZGVmaW5lZERhdGVSYW5nZS52YWx1ZS5zdGFydDtcbiAgICB0aGlzLnRvRGF0ZSA9IGRlZmluZWREYXRlUmFuZ2UudmFsdWUuZW5kO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvQXBwbHkpIHtcbiAgICAgIHRoaXMuYXBwbHkoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlQW5kQXNzaWduUHJlZGVmaW5lZFJhbmdlcyhyYW5nZXM6IElEZWZpbmVkRGF0ZVJhbmdlW10pOiBJRGVmaW5lZERhdGVSYW5nZVtdIHtcbiAgICByZXR1cm4gcmFuZ2VzLmZpbHRlcihyYW5nZSA9PiB7XG4gICAgICBpZiAocmFuZ2UudmFsdWUuc3RhcnQuaXNBZnRlcihyYW5nZS52YWx1ZS5lbmQsICdkYXRlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFByZS1kZWZpbmVkIHJhbmdlIFwiJHsgcmFuZ2UubmFtZSB9XCIgc3RhcnQgZGF0ZSBjYW5ub3QgYmUgYWZ0ZXIgdGhlIGVuZCBkYXRlIGZvciB0aGUgcmFuZ2UuYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluRGF0ZSAmJiByYW5nZS52YWx1ZS5zdGFydC5pc0JlZm9yZSh0aGlzLm9wdGlvbnMubWluRGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFByZS1kZWZpbmVkIHJhbmdlIFwiJHsgcmFuZ2UubmFtZSB9XCIgc3RhcnQgZGF0ZSBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBtaW5EYXRlIGluIHlvdXIgb3B0aW9ucy5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhEYXRlICYmIHJhbmdlLnZhbHVlLmVuZC5pc0FmdGVyKHRoaXMub3B0aW9ucy5tYXhEYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUHJlLWRlZmluZWQgcmFuZ2UgXCIkeyByYW5nZS5uYW1lIH1cIiBlbmQgZGF0ZSBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIG1heERhdGUgaW4geW91ciBvcHRpb25zLmApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcmFuZ2UgdG8gcmFuZ2VzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzQXV0b0FwcGx5KCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlQ2FsZW5kYXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b0FwcGx5O1xuICAgIH1cbiAgfVxufVxuIl19