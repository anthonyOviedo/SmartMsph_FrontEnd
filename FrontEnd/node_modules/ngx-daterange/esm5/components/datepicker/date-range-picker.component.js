import * as tslib_1 from "tslib";
import { Component, Input, Output, EventEmitter, HostListener, ViewEncapsulation } from '@angular/core';
import { FormGroup, FormControl } from '@angular/forms';
import { defaultDateRangePickerOptions } from '../../constants';
import * as momentNs from 'moment';
var moment = momentNs;
var instanceCount = 0;
var DateRangePickerComponent = /** @class */ (function () {
    function DateRangePickerComponent() {
        this.options = defaultDateRangePickerOptions;
        this.controlName = 'dateRange';
        this.instanceId = null;
        this.fromDate = null;
        this.toDate = null;
        this.rangeSelected = new EventEmitter();
        this.range = '';
        this.showCalendars = false;
        if (!this.instanceId) {
            // assign auto-id
            this.instanceId = "dateRangePicker-" + instanceCount++;
        }
    }
    Object.defineProperty(DateRangePickerComponent.prototype, "enableApplyButton", {
        get: function () {
            return !this.options.autoApply && !this.options.singleCalendar && this.fromDate !== null && this.toDate !== null;
        },
        enumerable: true,
        configurable: true
    });
    DateRangePickerComponent.prototype.handleClick = function (event) {
        var target = event.target;
        // close the DatePicker if clicking outside is not allowed
        if (!this.options.clickOutsideAllowed) {
            var containerElementClassRoot_1 = 'dateRangePicker';
            var targetPathClassNames = event['path'].map(function (obj) { return obj.className; }) || [''];
            var targetExistsInPath = targetPathClassNames.some(function (className) {
                if (typeof className === 'string') {
                    return className && className.includes(containerElementClassRoot_1);
                }
                return false;
            });
            if (!targetExistsInPath) {
                this.toggleCalendarVisibility(false);
            }
        }
        // Close the DatePicker if the target input was clicked
        if (target.id === this.instanceId) {
            this.toggleCalendarVisibility(!this.showCalendars);
        }
    };
    DateRangePickerComponent.prototype.ngOnInit = function () {
        var _this = this;
        // ensure dates in options are valid
        this.validateOptionDates();
        // ensure input dates are within the min/max dates in options
        this.validateInputDates();
        if (this.options.preDefinedRanges && this.options.preDefinedRanges.length > 0) {
            this.defaultRanges = this.validateAndAssignPredefinedRanges(this.options.preDefinedRanges);
        }
        // assign values not present in options with default values
        var optionsKeys = Object.keys(this.options);
        var defaultValuesKeys = Object.keys(defaultDateRangePickerOptions);
        defaultValuesKeys.forEach(function (key) {
            if (!optionsKeys.includes(key)) {
                _this.options[key] = defaultDateRangePickerOptions[key];
            }
        });
        // update calendar grid
        this.updateCalendar();
        // create parent form group if it doesn't exist
        if (!this.parentFormGroup) {
            this.parentFormGroup = new FormGroup({});
        }
        // add form control to parent form group
        var value = this.formatRangeAsString();
        var control = new FormControl(value, this.options.validators);
        if (this.options.disabled) {
            control.disable();
        }
        this.parentFormGroup.addControl(this.controlName, control);
        // set value of control
        this.setRange();
    };
    DateRangePickerComponent.prototype.validateInputDates = function () {
        if (this.fromDate && this.options.minDate && this.fromDate.isBefore(this.options.minDate, 'date')) {
            throw new RangeError('@Input fromDate is before the specified minDate in options');
        }
        if (this.toDate && this.options.maxDate && this.toDate.isAfter(this.options.maxDate, 'date')) {
            throw new RangeError('@Input toDate is after the specified maxDate in options');
        }
    };
    DateRangePickerComponent.prototype.validateOptionDates = function () {
        // validate maxDate isn't before minDate or vice versa
        if (this.options) {
            if (this.options.minDate && this.options.maxDate) {
                if (this.options.minDate.isAfter(this.options.maxDate, 'date')) {
                    throw new RangeError('minDate specified in options is after the maxDate');
                }
                else if (this.options.maxDate.isBefore(this.options.minDate, 'date')) {
                    throw new RangeError('maxDate specified in options is before the minDate');
                }
            }
        }
    };
    // assists CSS to fix small positioning bug with From:/To: date text
    DateRangePickerComponent.prototype.checkChrome = function () {
        return window['chrome'] ? 'is-chrome' : '';
    };
    DateRangePickerComponent.prototype.toggleCalendarVisibility = function (value) {
        this.showCalendars = value !== null ? value : !this.showCalendars;
    };
    DateRangePickerComponent.prototype.setFromToMonthYear = function (fromDate, toDate) {
        var tempFromDate = fromDate || this.fromDate || this.options.startingFromDate || moment();
        var tempToDate = toDate || this.toDate || this.options.startingToDate || moment();
        this.fromMonth = tempFromDate.get('month');
        this.fromYear = tempFromDate.get('year');
        this.toMonth = tempToDate.get('month');
        this.toYear = tempToDate.get('year');
    };
    DateRangePickerComponent.prototype.updateCalendar = function () {
        // get month and year to show calendar
        this.setFromToMonthYear();
        this.setRange();
    };
    // update from/to based on selection
    DateRangePickerComponent.prototype.dateChanged = function (changedData) {
        var value = changedData.day;
        var isLeft = changedData.isLeft;
        if (isLeft) {
            this.fromDate = value;
            if (this.fromDate.isAfter(this.toDate, 'date')) {
                this.toDate = this.fromDate.clone();
            }
        }
        else {
            this.toDate = value;
            if (this.toDate.isBefore(this.fromDate, 'date')) {
                this.fromDate = this.toDate.clone();
            }
        }
        this.setFromToMonthYear(this.fromDate, this.toDate);
        if (this.isAutoApply() && (this.options.singleCalendar || !isLeft) && this.fromDate) {
            this.toggleCalendarVisibility(false);
            this.setRange();
            this.emitRangeSelected();
        }
    };
    DateRangePickerComponent.prototype.emitRangeSelected = function (data) {
        if (!data) {
            data = this.options.singleCalendar ? { start: this.fromDate } : { start: this.fromDate, end: this.toDate };
        }
        this.rangeSelected.emit(data);
    };
    DateRangePickerComponent.prototype.getMoment = function (value) {
        return moment(value, this.options.format);
    };
    DateRangePickerComponent.prototype.formatRangeAsString = function () {
        var range = '';
        if (this.options.singleCalendar && this.fromDate) {
            range = this.fromDate.format(this.options.format);
        }
        else if (!this.options.singleCalendar && this.fromDate && this.toDate) {
            range = this.fromDate.format(this.options.format) + " - " + this.toDate.format(this.options.format);
        }
        return range;
    };
    DateRangePickerComponent.prototype.setRange = function () {
        this.range = this.formatRangeAsString();
        if (this.parentFormGroup) {
            var control = this.parentFormGroup.get(this.controlName);
            if (control) {
                control.setValue(this.range);
                control.updateValueAndValidity();
            }
        }
    };
    DateRangePickerComponent.prototype.setDateFromInput = function (event, isLeft) {
        if (isLeft === void 0) { isLeft = false; }
        var target = event.target;
        try {
            if (target.value) {
                var day = this.getMoment(target.value);
                if (!day.isBefore(this.options.minDate) && !day.isAfter(this.options.maxDate)) {
                    if (isLeft && !this.fromDate) {
                        this.fromDate = day;
                    }
                    if (!isLeft && !this.toDate) {
                        this.toDate = day;
                    }
                    this.dateChanged({
                        day: day,
                        isLeft: isLeft,
                    });
                    this.setFromToMonthYear(this.fromDate, this.toDate);
                }
                else {
                    // assume nothing - reset values
                    this.fromDate = null;
                    this.toDate = null;
                    target.value = '';
                    target.focus();
                }
            }
            this.emitRangeSelected();
        }
        catch (e) {
            console.error(e);
        }
    };
    DateRangePickerComponent.prototype.monthChanged = function (data) {
        var temp;
        if (data.isLeft) {
            temp = moment([this.fromYear, this.fromMonth]).add(data.value, 'months');
            this.fromMonth = temp.get('month');
            this.fromYear = temp.get('year');
        }
        else {
            temp = moment([this.toYear, this.toMonth]).add(data.value, 'months');
            this.toMonth = temp.get('month');
            this.toYear = temp.get('year');
        }
    };
    DateRangePickerComponent.prototype.yearChanged = function (data) {
        var temp;
        if (data.isLeft) {
            temp = moment([this.fromYear, this.fromMonth]).add(data.value, 'year');
            this.fromMonth = temp.get('month');
            this.fromYear = temp.get('year');
        }
        else {
            temp = moment([this.toYear, this.toMonth]).add(data.value, 'year');
            this.toMonth = temp.get('month');
            this.toYear = temp.get('year');
        }
    };
    DateRangePickerComponent.prototype.close = function (event) {
        this.toggleCalendarVisibility(false);
        event.stopPropagation();
    };
    DateRangePickerComponent.prototype.reset = function (event) {
        this.fromDate = null;
        this.toDate = null;
        this.setRange();
        event.stopPropagation();
    };
    DateRangePickerComponent.prototype.apply = function (event) {
        this.toggleCalendarVisibility(false);
        this.setRange();
        this.emitRangeSelected();
        event.stopPropagation();
    };
    DateRangePickerComponent.prototype.applyPredefinedRange = function (event, definedDateRange) {
        // adjust to/from month/year so calendar months and years match range
        this.setFromToMonthYear(definedDateRange.value.start, definedDateRange.value.end);
        this.fromDate = definedDateRange.value.start;
        this.toDate = definedDateRange.value.end;
        if (this.options.autoApply) {
            this.apply(event);
        }
    };
    DateRangePickerComponent.prototype.validateAndAssignPredefinedRanges = function (ranges) {
        var _this = this;
        return ranges.filter(function (range) {
            if (range.value.start.isAfter(range.value.end, 'date')) {
                throw new RangeError("Pre-defined range \"" + range.name + "\" start date cannot be after the end date for the range.");
            }
            if (_this.options.minDate && range.value.start.isBefore(_this.options.minDate)) {
                throw new RangeError("Pre-defined range \"" + range.name + "\" start date is before the specified minDate in your options.");
            }
            if (_this.options.maxDate && range.value.end.isAfter(_this.options.maxDate)) {
                throw new RangeError("Pre-defined range \"" + range.name + "\" end date is after the specified maxDate in your options.");
            }
            // add range to ranges
            return true;
        });
    };
    DateRangePickerComponent.prototype.isAutoApply = function () {
        if (this.options.singleCalendar) {
            return true;
        }
        else {
            return this.options.autoApply;
        }
    };
    tslib_1.__decorate([
        Input()
    ], DateRangePickerComponent.prototype, "options", void 0);
    tslib_1.__decorate([
        Input()
    ], DateRangePickerComponent.prototype, "controlName", void 0);
    tslib_1.__decorate([
        Input()
    ], DateRangePickerComponent.prototype, "instanceId", void 0);
    tslib_1.__decorate([
        Input()
    ], DateRangePickerComponent.prototype, "parentFormGroup", void 0);
    tslib_1.__decorate([
        Input()
    ], DateRangePickerComponent.prototype, "fromDate", void 0);
    tslib_1.__decorate([
        Input()
    ], DateRangePickerComponent.prototype, "toDate", void 0);
    tslib_1.__decorate([
        Output()
    ], DateRangePickerComponent.prototype, "rangeSelected", void 0);
    tslib_1.__decorate([
        HostListener('document:click', ['$event'])
    ], DateRangePickerComponent.prototype, "handleClick", null);
    DateRangePickerComponent = tslib_1.__decorate([
        Component({
            encapsulation: ViewEncapsulation.None,
            selector: 'date-range-picker',
            template: "<div class=\"dateRangePicker-wrapper\" *ngIf=\"parentFormGroup\">\n  <div #content>\n    <ng-content></ng-content>\n  </div>\n  <div class=\"form-group\" [formGroup]=\"parentFormGroup\">\n    <ng-container *ngIf=\"content.childNodes.length === 0\">\n      <label [attr.for]=\"instanceId\">{{ options.labelText }}</label>\n      <input [attr.id]=\"instanceId\" class=\"form-control\" type=\"text\" [formControlName]=\"controlName\">\n    </ng-container>\n\n    <div [ngClass]=\"{'dateRangePicker': true, 'invisible': !showCalendars, 'dateRangePicker-single': options.singleCalendar, 'is-chrome': checkChrome(), 'open-left': options.position === 'left', 'open-right': options.position === 'right' }\">\n      <div class=\"container-fluid\">\n        <div class=\"row\">\n          <div class=\"col\">\n\n            <div class=\"row form-inputs mb-0\" *ngIf=\"!options.singleCalendar\">\n\n              <div class=\"col\">\n                <div class=\"\" *ngIf=\"options.icons !== 'default'\">\n                  <div [ngClass]=\"{ 'd-flex align-items-center input-with-icon': true, 'material': options.icons === 'material'}\">\n                    <i *ngIf=\"options.icons === 'material'\" class=\"material-icons\">event</i>\n                    <i *ngIf=\"options.icons === 'font-awesome'\" class=\"far fa-calendar-alt\"></i>\n                    <span *ngIf=\"fromDate\">From:&nbsp;</span>\n                    <input class=\"form-control\" [ngModel]=\"fromDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event, true)\" type=\"text\" name=\"daterangepicker_start\" [ngModelOptions]=\"{ standalone: true }\" placeholder=\"Select From Date\" />\n                  </div>\n                </div>\n\n                <input *ngIf=\"options.icons === 'default'\" class=\"form-control\" [ngModel]=\"fromDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event, true)\" type=\"text\" name=\"daterangepicker_start\" [ngModelOptions]=\"{standalone: true}\" placeholder=\"Select From Date\" />\n              </div>\n\n              <div class=\"col\">\n                <div class=\"\" *ngIf=\"options.icons !== 'default'\">\n                    <div [ngClass]=\"{ 'd-flex align-items-center input-with-icon': true, 'material': options.icons === 'material'}\">\n                      <i *ngIf=\"options.icons === 'material'\" class=\"material-icons\">event</i>\n                      <i *ngIf=\"options.icons === 'font-awesome'\" class=\"far fa-calendar-alt\"></i>\n                      <span *ngIf=\"toDate\">To:&nbsp;</span>\n                      <input class=\"form-control\" [ngModel]=\"toDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event)\" type=\"text\" name=\"daterangepicker_end\" [ngModelOptions]=\"{ standalone: true }\" placeholder=\"Select To Date\" />\n                    </div>\n                  </div>\n\n                <input *ngIf=\"options.icons === 'default'\" class=\"form-control\" [ngModel]=\"toDate | formatMomentDate: options.format\" (blur)=\"setDateFromInput($event)\" name=\"daterangepicker_end\" [ngModelOptions]=\"{standalone: true}\" />\n              </div>\n\n            </div>\n\n            <div class=\"row row-calendars\">\n              <div class=\"col\">\n                <calendar [ngClass]=\"{ 'calendar': true, 'calendar-single': options.singleCalendar }\" [isLeft]=\"true\" [month]=\"fromMonth\" [year]=\"fromYear\" (monthChanged)=monthChanged($event)\n                  (yearChanged)=\"yearChanged($event)\" (dateChanged)=\"dateChanged($event)\" [format]=\"options.format\" [selectedFromDate]=\"fromDate\"\n                  [selectedToDate]=\"toDate\" [minDate]=\"options.minDate\" [maxDate]=\"options.maxDate\" [singleCalendar]=\"options.singleCalendar\" [icons]=\"options.icons\"></calendar>\n              </div>\n\n              <div class=\"col\" *ngIf=\"!options.singleCalendar\">\n                <calendar class=\"calendar\" [month]=\"toMonth\" [year]=\"toYear\" [format]=\"options.format\" (dateChanged)=\"dateChanged($event)\" (monthChanged)=\"monthChanged($event)\" (yearChanged)=yearChanged($event) [selectedFromDate]=\"fromDate\" [selectedToDate]=\"toDate\" [minDate]=\"options.minDate\" [maxDate]=\"options.maxDate\" [icons]=\"options.icons\"></calendar>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"row text-center my-3\" *ngIf=\"!options.singleCalendar\">\n          <div class=\"col\">\n            <div class=\"row mb-2\" *ngIf=\"options.preDefinedRanges && options.preDefinedRanges.length > 0\">\n              <div class=\"col\">\n                <button type=\"button\" *ngFor=\"let range of options.preDefinedRanges\" class=\"btn btn-link\" (click)=\"applyPredefinedRange($event, range)\">{{ range.name }}</button>\n              </div>\n            </div>\n            <button type=\"button\" class=\"btn btn-outline-secondary btn-sm\" (click)=\"close($event)\">Close</button>\n            <button type=\"button\" class=\"btn btn-outline-secondary btn-sm ml-3\" (click)=\"reset($event)\" *ngIf=\"this.range\">Reset</button>\n            <button type=\"button\" class=\"btn btn-primary btn-sm ml-3\" [disabled]=\"!enableApplyButton\" (click)=\"apply($event)\" *ngIf=\"!isAutoApply()\">Apply</button>\n          </div>\n        </div>\n\n      </div>\n    </div>\n\n  </div>\n</div>\n",
            styles: [".dateRangePicker-wrapper{position:relative;border:none}.dateRangePicker-wrapper .dateRangePicker{background:#fff;border-radius:9px;box-shadow:0 0 10px 0 rgba(129,139,144,.5);font-family:Roboto,Helvetica,Arial,sans-serif;overflow:visible;position:absolute;top:88px;z-index:3000}.dateRangePicker-wrapper .dateRangePicker.dateRangePicker-single{min-width:300px}@media screen and (min-width:576px){.dateRangePicker-wrapper .dateRangePicker{min-width:600px}}.dateRangePicker-wrapper .dateRangePicker::after,.dateRangePicker-wrapper .dateRangePicker::before{content:\"\";height:0;width:0;border-bottom:10px solid #6e777c;border-left:10px solid transparent;border-right:10px solid transparent;position:absolute;top:-10px}.dateRangePicker-wrapper .dateRangePicker.open-left{left:0}.dateRangePicker-wrapper .dateRangePicker.open-left::before{left:10px}.dateRangePicker-wrapper .dateRangePicker.open-left::after{display:none}.dateRangePicker-wrapper .dateRangePicker.open-right{right:0}.dateRangePicker-wrapper .dateRangePicker.open-right::before{display:none}.dateRangePicker-wrapper .dateRangePicker.open-right::after{right:10px}.dateRangePicker-wrapper .dateRangePicker.is-chrome .form-inputs .input-with-icon span{position:relative;top:1px}.dateRangePicker-wrapper .dateRangePicker .btn,.dateRangePicker-wrapper .dateRangePicker .btn.btn-link{min-width:auto;width:auto}.dateRangePicker-wrapper .dateRangePicker .form-inputs{background-color:#6e777c;border-top-left-radius:8px;border-top-right-radius:8px;color:#fff;font-size:16px}.dateRangePicker-wrapper .dateRangePicker .form-inputs>.col{padding:.5rem 15px;min-width:270px}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon{display:flex;align-content:flex-start;align-items:center!important}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon i{color:#fff;margin-right:.5rem}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon i.material-icons{top:0}.dateRangePicker-wrapper .dateRangePicker .form-inputs .input-with-icon span{line-height:1}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control{background:0 0;border:0;color:#fff;display:inline-block;padding:0;width:150px}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::-webkit-input-placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::-moz-placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::-ms-input-placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs .form-control::placeholder{color:#fff}.dateRangePicker-wrapper .dateRangePicker .form-inputs>div:nth-child(2),.dateRangePicker-wrapper .dateRangePicker .row-calendars>div:nth-child(2){border-left:2px solid #c6d1d6}.dateRangePicker-wrapper i.material-icons{position:relative;top:2px}"]
        })
    ], DateRangePickerComponent);
    return DateRangePickerComponent;
}());
export { DateRangePickerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWRhdGVyYW5nZS8iLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvZGF0ZXBpY2tlci9kYXRlLXJhbmdlLXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFVLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hILE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEQsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHaEUsT0FBTyxLQUFLLFFBQVEsTUFBTSxRQUFRLENBQUM7QUFBQyxJQUFNLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFFNUQsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO0FBVXRCO0lBOERFO1FBM0RBLFlBQU8sR0FBNEIsNkJBQTZCLENBQUM7UUFHakUsZ0JBQVcsR0FBVyxXQUFXLENBQUM7UUFHbEMsZUFBVSxHQUFXLElBQUksQ0FBQztRQU0xQixhQUFRLEdBQW9CLElBQUksQ0FBQztRQUdqQyxXQUFNLEdBQW9CLElBQUksQ0FBQztRQUcvQixrQkFBYSxHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFPL0MsVUFBSyxHQUFHLEVBQUUsQ0FBQztRQUNYLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBa0NwQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNwQixpQkFBaUI7WUFDakIsSUFBSSxDQUFDLFVBQVUsR0FBRyxxQkFBb0IsYUFBYSxFQUFLLENBQUM7U0FDMUQ7SUFDSCxDQUFDO0lBcENELHNCQUFJLHVEQUFpQjthQUFyQjtZQUNFLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FB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Q29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUdyb3VwLCBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgZGVmYXVsdERhdGVSYW5nZVBpY2tlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgSURhdGVSYW5nZSwgSURhdGVSYW5nZVBpY2tlck9wdGlvbnMsIElEZWZpbmVkRGF0ZVJhbmdlLCBJQ2hhbmdlZERhdGEgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzJztcblxuaW1wb3J0ICogYXMgbW9tZW50TnMgZnJvbSAnbW9tZW50JzsgY29uc3QgbW9tZW50ID0gbW9tZW50TnM7XG5cbmxldCBpbnN0YW5jZUNvdW50ID0gMDtcblxuQENvbXBvbmVudCh7XG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIHNlbGVjdG9yOiAnZGF0ZS1yYW5nZS1waWNrZXInLFxuICBzdHlsZVVybHM6IFtcbiAgICAnLi9kYXRlLXJhbmdlLXBpY2tlci5jb21wb25lbnQuc2NzcycsXG4gIF0sXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRlLXJhbmdlLXBpY2tlci5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIERhdGVSYW5nZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KClcbiAgb3B0aW9uczogSURhdGVSYW5nZVBpY2tlck9wdGlvbnMgPSBkZWZhdWx0RGF0ZVJhbmdlUGlja2VyT3B0aW9ucztcblxuICBASW5wdXQoKVxuICBjb250cm9sTmFtZTogc3RyaW5nID0gJ2RhdGVSYW5nZSc7XG5cbiAgQElucHV0KClcbiAgaW5zdGFuY2VJZDogc3RyaW5nID0gbnVsbDtcblxuICBASW5wdXQoKVxuICBwYXJlbnRGb3JtR3JvdXA6IEZvcm1Hcm91cDtcblxuICBASW5wdXQoKVxuICBmcm9tRGF0ZTogbW9tZW50TnMuTW9tZW50ID0gbnVsbDtcblxuICBASW5wdXQoKVxuICB0b0RhdGU6IG1vbWVudE5zLk1vbWVudCA9IG51bGw7XG5cbiAgQE91dHB1dCgpXG4gIHJhbmdlU2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElEYXRlUmFuZ2U+KCk7XG5cbiAgZGVmYXVsdFJhbmdlczogSURlZmluZWREYXRlUmFuZ2VbXTtcbiAgZnJvbU1vbnRoOiBudW1iZXI7XG4gIGZyb21ZZWFyOiBudW1iZXI7XG4gIHRvTW9udGg6IG51bWJlcjtcbiAgdG9ZZWFyOiBudW1iZXI7XG4gIHJhbmdlID0gJyc7XG4gIHNob3dDYWxlbmRhcnMgPSBmYWxzZTtcblxuICBnZXQgZW5hYmxlQXBwbHlCdXR0b24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLm9wdGlvbnMuYXV0b0FwcGx5ICYmICF0aGlzLm9wdGlvbnMuc2luZ2xlQ2FsZW5kYXIgJiYgdGhpcy5mcm9tRGF0ZSAhPT0gbnVsbCAmJiB0aGlzLnRvRGF0ZSAhPT0gbnVsbDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgaGFuZGxlQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICAvLyBjbG9zZSB0aGUgRGF0ZVBpY2tlciBpZiBjbGlja2luZyBvdXRzaWRlIGlzIG5vdCBhbGxvd2VkXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY2xpY2tPdXRzaWRlQWxsb3dlZCkge1xuICAgICAgY29uc3QgY29udGFpbmVyRWxlbWVudENsYXNzUm9vdCA9ICdkYXRlUmFuZ2VQaWNrZXInO1xuICAgICAgY29uc3QgdGFyZ2V0UGF0aENsYXNzTmFtZXM6IHN0cmluZ1tdID0gZXZlbnRbJ3BhdGgnXS5tYXAob2JqID0+IG9iai5jbGFzc05hbWUpIHx8IFsnJ107XG4gICAgICBjb25zdCB0YXJnZXRFeGlzdHNJblBhdGggPSB0YXJnZXRQYXRoQ2xhc3NOYW1lcy5zb21lKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluY2x1ZGVzKGNvbnRhaW5lckVsZW1lbnRDbGFzc1Jvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGFyZ2V0RXhpc3RzSW5QYXRoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQ2FsZW5kYXJWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbG9zZSB0aGUgRGF0ZVBpY2tlciBpZiB0aGUgdGFyZ2V0IGlucHV0IHdhcyBjbGlja2VkXG4gICAgaWYgKHRhcmdldC5pZCA9PT0gdGhpcy5pbnN0YW5jZUlkKSB7XG4gICAgICB0aGlzLnRvZ2dsZUNhbGVuZGFyVmlzaWJpbGl0eSghdGhpcy5zaG93Q2FsZW5kYXJzKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2VJZCkge1xuICAgICAgLy8gYXNzaWduIGF1dG8taWRcbiAgICAgIHRoaXMuaW5zdGFuY2VJZCA9IGBkYXRlUmFuZ2VQaWNrZXItJHsgaW5zdGFuY2VDb3VudCsrIH1gO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIC8vIGVuc3VyZSBkYXRlcyBpbiBvcHRpb25zIGFyZSB2YWxpZFxuICAgIHRoaXMudmFsaWRhdGVPcHRpb25EYXRlcygpO1xuXG4gICAgLy8gZW5zdXJlIGlucHV0IGRhdGVzIGFyZSB3aXRoaW4gdGhlIG1pbi9tYXggZGF0ZXMgaW4gb3B0aW9uc1xuICAgIHRoaXMudmFsaWRhdGVJbnB1dERhdGVzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZURlZmluZWRSYW5nZXMgJiYgdGhpcy5vcHRpb25zLnByZURlZmluZWRSYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5kZWZhdWx0UmFuZ2VzID0gdGhpcy52YWxpZGF0ZUFuZEFzc2lnblByZWRlZmluZWRSYW5nZXModGhpcy5vcHRpb25zLnByZURlZmluZWRSYW5nZXMpO1xuICAgIH1cblxuICAgIC8vIGFzc2lnbiB2YWx1ZXMgbm90IHByZXNlbnQgaW4gb3B0aW9ucyB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgY29uc3Qgb3B0aW9uc0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXNLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdERhdGVSYW5nZVBpY2tlck9wdGlvbnMpO1xuXG4gICAgZGVmYXVsdFZhbHVlc0tleXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICghb3B0aW9uc0tleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IGRlZmF1bHREYXRlUmFuZ2VQaWNrZXJPcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgY2FsZW5kYXIgZ3JpZFxuICAgIHRoaXMudXBkYXRlQ2FsZW5kYXIoKTtcblxuICAgIC8vIGNyZWF0ZSBwYXJlbnQgZm9ybSBncm91cCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCF0aGlzLnBhcmVudEZvcm1Hcm91cCkge1xuICAgICAgdGhpcy5wYXJlbnRGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgZm9ybSBjb250cm9sIHRvIHBhcmVudCBmb3JtIGdyb3VwXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm1hdFJhbmdlQXNTdHJpbmcoKTtcbiAgICBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKHZhbHVlLCB0aGlzLm9wdGlvbnMudmFsaWRhdG9ycyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICBjb250cm9sLmRpc2FibGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudEZvcm1Hcm91cC5hZGRDb250cm9sKHRoaXMuY29udHJvbE5hbWUsIGNvbnRyb2wpO1xuXG4gICAgLy8gc2V0IHZhbHVlIG9mIGNvbnRyb2xcbiAgICB0aGlzLnNldFJhbmdlKCk7XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0RGF0ZXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZnJvbURhdGUgJiYgdGhpcy5vcHRpb25zLm1pbkRhdGUgJiYgdGhpcy5mcm9tRGF0ZS5pc0JlZm9yZSh0aGlzLm9wdGlvbnMubWluRGF0ZSwgJ2RhdGUnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0BJbnB1dCBmcm9tRGF0ZSBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBtaW5EYXRlIGluIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b0RhdGUgJiYgdGhpcy5vcHRpb25zLm1heERhdGUgJiYgdGhpcy50b0RhdGUuaXNBZnRlcih0aGlzLm9wdGlvbnMubWF4RGF0ZSwgJ2RhdGUnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0BJbnB1dCB0b0RhdGUgaXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBtYXhEYXRlIGluIG9wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZU9wdGlvbkRhdGVzKCk6IHZvaWQge1xuICAgIC8vIHZhbGlkYXRlIG1heERhdGUgaXNuJ3QgYmVmb3JlIG1pbkRhdGUgb3IgdmljZSB2ZXJzYVxuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluRGF0ZSAmJiB0aGlzLm9wdGlvbnMubWF4RGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pbkRhdGUuaXNBZnRlcih0aGlzLm9wdGlvbnMubWF4RGF0ZSwgJ2RhdGUnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaW5EYXRlIHNwZWNpZmllZCBpbiBvcHRpb25zIGlzIGFmdGVyIHRoZSBtYXhEYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heERhdGUuaXNCZWZvcmUodGhpcy5vcHRpb25zLm1pbkRhdGUsICdkYXRlJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4RGF0ZSBzcGVjaWZpZWQgaW4gb3B0aW9ucyBpcyBiZWZvcmUgdGhlIG1pbkRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lzdHMgQ1NTIHRvIGZpeCBzbWFsbCBwb3NpdGlvbmluZyBidWcgd2l0aCBGcm9tOi9UbzogZGF0ZSB0ZXh0XG4gIGNoZWNrQ2hyb21lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHdpbmRvd1snY2hyb21lJ10gPyAnaXMtY2hyb21lJyA6ICcnO1xuICB9XG5cbiAgdG9nZ2xlQ2FsZW5kYXJWaXNpYmlsaXR5KHZhbHVlPzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuc2hvd0NhbGVuZGFycyA9IHZhbHVlICE9PSBudWxsID8gdmFsdWUgOiAhdGhpcy5zaG93Q2FsZW5kYXJzO1xuICB9XG5cbiAgc2V0RnJvbVRvTW9udGhZZWFyKGZyb21EYXRlPzogbW9tZW50TnMuTW9tZW50LCB0b0RhdGU/OiBtb21lbnROcy5Nb21lbnQpOiB2b2lkIHtcbiAgICBjb25zdCB0ZW1wRnJvbURhdGUgPSBmcm9tRGF0ZSB8fCB0aGlzLmZyb21EYXRlIHx8IHRoaXMub3B0aW9ucy5zdGFydGluZ0Zyb21EYXRlIHx8IG1vbWVudCgpO1xuICAgIGNvbnN0IHRlbXBUb0RhdGUgPSB0b0RhdGUgfHwgdGhpcy50b0RhdGUgfHwgdGhpcy5vcHRpb25zLnN0YXJ0aW5nVG9EYXRlIHx8IG1vbWVudCgpO1xuXG4gICAgdGhpcy5mcm9tTW9udGggPSB0ZW1wRnJvbURhdGUuZ2V0KCdtb250aCcpO1xuICAgIHRoaXMuZnJvbVllYXIgPSB0ZW1wRnJvbURhdGUuZ2V0KCd5ZWFyJyk7XG5cbiAgICB0aGlzLnRvTW9udGggPSB0ZW1wVG9EYXRlLmdldCgnbW9udGgnKTtcbiAgICB0aGlzLnRvWWVhciA9IHRlbXBUb0RhdGUuZ2V0KCd5ZWFyJyk7XG4gIH1cblxuICB1cGRhdGVDYWxlbmRhcigpOiB2b2lkIHtcbiAgICAvLyBnZXQgbW9udGggYW5kIHllYXIgdG8gc2hvdyBjYWxlbmRhclxuICAgIHRoaXMuc2V0RnJvbVRvTW9udGhZZWFyKCk7XG4gICAgdGhpcy5zZXRSYW5nZSgpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGZyb20vdG8gYmFzZWQgb24gc2VsZWN0aW9uXG4gIGRhdGVDaGFuZ2VkKGNoYW5nZWREYXRhOiBJQ2hhbmdlZERhdGEpOiB2b2lkIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZWREYXRhLmRheTtcbiAgICBjb25zdCBpc0xlZnQgPSBjaGFuZ2VkRGF0YS5pc0xlZnQ7XG5cbiAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICB0aGlzLmZyb21EYXRlID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLmZyb21EYXRlLmlzQWZ0ZXIodGhpcy50b0RhdGUsICdkYXRlJykpIHtcbiAgICAgICAgdGhpcy50b0RhdGUgPSB0aGlzLmZyb21EYXRlLmNsb25lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy50b0RhdGUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudG9EYXRlLmlzQmVmb3JlKHRoaXMuZnJvbURhdGUsICdkYXRlJykpIHtcbiAgICAgICAgdGhpcy5mcm9tRGF0ZSA9IHRoaXMudG9EYXRlLmNsb25lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRGcm9tVG9Nb250aFllYXIodGhpcy5mcm9tRGF0ZSwgdGhpcy50b0RhdGUpO1xuXG4gICAgaWYgKHRoaXMuaXNBdXRvQXBwbHkoKSAmJiAodGhpcy5vcHRpb25zLnNpbmdsZUNhbGVuZGFyIHx8ICFpc0xlZnQpICYmIHRoaXMuZnJvbURhdGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlQ2FsZW5kYXJWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICAgIHRoaXMuc2V0UmFuZ2UoKTtcbiAgICAgIHRoaXMuZW1pdFJhbmdlU2VsZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBlbWl0UmFuZ2VTZWxlY3RlZChkYXRhPzogSURhdGVSYW5nZSk6IHZvaWQge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IHRoaXMub3B0aW9ucy5zaW5nbGVDYWxlbmRhciA/IHsgc3RhcnQ6IHRoaXMuZnJvbURhdGUgfSA6IHsgc3RhcnQ6IHRoaXMuZnJvbURhdGUsIGVuZDogdGhpcy50b0RhdGUgfTtcbiAgICB9XG5cbiAgICB0aGlzLnJhbmdlU2VsZWN0ZWQuZW1pdChkYXRhKTtcbiAgfVxuXG4gIGdldE1vbWVudCh2YWx1ZSk6IG1vbWVudE5zLk1vbWVudCB7XG4gICAgcmV0dXJuIG1vbWVudCh2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcm1hdCk7XG4gIH1cblxuICBmb3JtYXRSYW5nZUFzU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgbGV0IHJhbmdlID0gJyc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNpbmdsZUNhbGVuZGFyICYmIHRoaXMuZnJvbURhdGUpIHtcbiAgICAgIHJhbmdlID0gdGhpcy5mcm9tRGF0ZS5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuc2luZ2xlQ2FsZW5kYXIgJiYgdGhpcy5mcm9tRGF0ZSAmJiB0aGlzLnRvRGF0ZSkge1xuICAgICAgcmFuZ2UgPSBgJHsgdGhpcy5mcm9tRGF0ZS5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkgfSAtICR7IHRoaXMudG9EYXRlLmZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KSB9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBzZXRSYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5mb3JtYXRSYW5nZUFzU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5wYXJlbnRGb3JtR3JvdXApIHtcbiAgICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLnBhcmVudEZvcm1Hcm91cC5nZXQodGhpcy5jb250cm9sTmFtZSk7XG5cbiAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuc2V0VmFsdWUodGhpcy5yYW5nZSk7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldERhdGVGcm9tSW5wdXQoZXZlbnQ6IEV2ZW50LCBpc0xlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0YXJnZXQudmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGF5ID0gdGhpcy5nZXRNb21lbnQodGFyZ2V0LnZhbHVlKTtcblxuICAgICAgICBpZiAoIWRheS5pc0JlZm9yZSh0aGlzLm9wdGlvbnMubWluRGF0ZSkgJiYgIWRheS5pc0FmdGVyKHRoaXMub3B0aW9ucy5tYXhEYXRlKSkge1xuICAgICAgICAgIGlmIChpc0xlZnQgJiYgIXRoaXMuZnJvbURhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbURhdGUgPSBkYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0xlZnQgJiYgIXRoaXMudG9EYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRvRGF0ZSA9IGRheTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRhdGVDaGFuZ2VkKHtcbiAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgIGlzTGVmdCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuc2V0RnJvbVRvTW9udGhZZWFyKHRoaXMuZnJvbURhdGUsIHRoaXMudG9EYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBhc3N1bWUgbm90aGluZyAtIHJlc2V0IHZhbHVlc1xuICAgICAgICAgIHRoaXMuZnJvbURhdGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMudG9EYXRlID0gbnVsbDtcbiAgICAgICAgICB0YXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXRSYW5nZVNlbGVjdGVkKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIG1vbnRoQ2hhbmdlZChkYXRhOiBJQ2hhbmdlZERhdGEpOiB2b2lkIHtcbiAgICBsZXQgdGVtcDtcblxuICAgIGlmIChkYXRhLmlzTGVmdCkge1xuICAgICAgdGVtcCA9IG1vbWVudChbdGhpcy5mcm9tWWVhciwgdGhpcy5mcm9tTW9udGhdKS5hZGQoZGF0YS52YWx1ZSwgJ21vbnRocycpO1xuICAgICAgdGhpcy5mcm9tTW9udGggPSB0ZW1wLmdldCgnbW9udGgnKTtcbiAgICAgIHRoaXMuZnJvbVllYXIgPSB0ZW1wLmdldCgneWVhcicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRlbXAgPSBtb21lbnQoW3RoaXMudG9ZZWFyLCB0aGlzLnRvTW9udGhdKS5hZGQoZGF0YS52YWx1ZSwgJ21vbnRocycpO1xuICAgICAgdGhpcy50b01vbnRoID0gdGVtcC5nZXQoJ21vbnRoJyk7XG4gICAgICB0aGlzLnRvWWVhciA9IHRlbXAuZ2V0KCd5ZWFyJyk7XG4gICAgfVxuICB9XG5cbiAgeWVhckNoYW5nZWQoZGF0YTogSUNoYW5nZWREYXRhKTogdm9pZCB7XG4gICAgbGV0IHRlbXA7XG5cbiAgICBpZiAoZGF0YS5pc0xlZnQpIHtcbiAgICAgIHRlbXAgPSBtb21lbnQoW3RoaXMuZnJvbVllYXIsIHRoaXMuZnJvbU1vbnRoXSkuYWRkKGRhdGEudmFsdWUsICd5ZWFyJyk7XG4gICAgICB0aGlzLmZyb21Nb250aCA9IHRlbXAuZ2V0KCdtb250aCcpO1xuICAgICAgdGhpcy5mcm9tWWVhciA9IHRlbXAuZ2V0KCd5ZWFyJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGVtcCA9IG1vbWVudChbdGhpcy50b1llYXIsIHRoaXMudG9Nb250aF0pLmFkZChkYXRhLnZhbHVlLCAneWVhcicpO1xuICAgICAgdGhpcy50b01vbnRoID0gdGVtcC5nZXQoJ21vbnRoJyk7XG4gICAgICB0aGlzLnRvWWVhciA9IHRlbXAuZ2V0KCd5ZWFyJyk7XG4gICAgfVxuICB9XG5cbiAgY2xvc2UoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy50b2dnbGVDYWxlbmRhclZpc2liaWxpdHkoZmFsc2UpO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICByZXNldChldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLmZyb21EYXRlID0gbnVsbDtcbiAgICB0aGlzLnRvRGF0ZSA9IG51bGw7XG4gICAgdGhpcy5zZXRSYW5nZSgpO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBhcHBseShldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLnRvZ2dsZUNhbGVuZGFyVmlzaWJpbGl0eShmYWxzZSk7XG4gICAgdGhpcy5zZXRSYW5nZSgpO1xuICAgIHRoaXMuZW1pdFJhbmdlU2VsZWN0ZWQoKTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgYXBwbHlQcmVkZWZpbmVkUmFuZ2UoZXZlbnQ6IEV2ZW50LCBkZWZpbmVkRGF0ZVJhbmdlOiBJRGVmaW5lZERhdGVSYW5nZSk6IHZvaWQge1xuICAgIC8vIGFkanVzdCB0by9mcm9tIG1vbnRoL3llYXIgc28gY2FsZW5kYXIgbW9udGhzIGFuZCB5ZWFycyBtYXRjaCByYW5nZVxuICAgIHRoaXMuc2V0RnJvbVRvTW9udGhZZWFyKGRlZmluZWREYXRlUmFuZ2UudmFsdWUuc3RhcnQsIGRlZmluZWREYXRlUmFuZ2UudmFsdWUuZW5kKTtcblxuICAgIHRoaXMuZnJvbURhdGUgPSBkZWZpbmVkRGF0ZVJhbmdlLnZhbHVlLnN0YXJ0O1xuICAgIHRoaXMudG9EYXRlID0gZGVmaW5lZERhdGVSYW5nZS52YWx1ZS5lbmQ7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9BcHBseSkge1xuICAgICAgdGhpcy5hcHBseShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVBbmRBc3NpZ25QcmVkZWZpbmVkUmFuZ2VzKHJhbmdlczogSURlZmluZWREYXRlUmFuZ2VbXSk6IElEZWZpbmVkRGF0ZVJhbmdlW10ge1xuICAgIHJldHVybiByYW5nZXMuZmlsdGVyKHJhbmdlID0+IHtcbiAgICAgIGlmIChyYW5nZS52YWx1ZS5zdGFydC5pc0FmdGVyKHJhbmdlLnZhbHVlLmVuZCwgJ2RhdGUnKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUHJlLWRlZmluZWQgcmFuZ2UgXCIkeyByYW5nZS5uYW1lIH1cIiBzdGFydCBkYXRlIGNhbm5vdCBiZSBhZnRlciB0aGUgZW5kIGRhdGUgZm9yIHRoZSByYW5nZS5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5EYXRlICYmIHJhbmdlLnZhbHVlLnN0YXJ0LmlzQmVmb3JlKHRoaXMub3B0aW9ucy5taW5EYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUHJlLWRlZmluZWQgcmFuZ2UgXCIkeyByYW5nZS5uYW1lIH1cIiBzdGFydCBkYXRlIGlzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG1pbkRhdGUgaW4geW91ciBvcHRpb25zLmApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1heERhdGUgJiYgcmFuZ2UudmFsdWUuZW5kLmlzQWZ0ZXIodGhpcy5vcHRpb25zLm1heERhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQcmUtZGVmaW5lZCByYW5nZSBcIiR7IHJhbmdlLm5hbWUgfVwiIGVuZCBkYXRlIGlzIGFmdGVyIHRoZSBzcGVjaWZpZWQgbWF4RGF0ZSBpbiB5b3VyIG9wdGlvbnMuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCByYW5nZSB0byByYW5nZXNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgaXNBdXRvQXBwbHkoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaW5nbGVDYWxlbmRhcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdXRvQXBwbHk7XG4gICAgfVxuICB9XG59XG4iXX0=